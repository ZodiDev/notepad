<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #000000;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --accent: #007aff;
            --accent-hover: #0051d5;
            --danger: #ff3b30;
            --warning: #ff9500;
            --border: #333333;
            --shadow: rgba(0, 0, 0, 0.5);
            --note-bg: #1f1f1f;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            height: 100dvh;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .container {
            display: flex;
            height: 100dvh;
            overflow: hidden;
            position: relative;
        }

        /* Sidebar */
        .sidebar {
            width: 100%;
            background-color: var(--bg-primary);
            display: flex;
            flex-direction: column;
            position: absolute;
            z-index: 10;
            height: 100%;
        }

        .sidebar.hidden {
            display: none;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .app-title {
            font-size: 28px;
            font-weight: 300;
            margin-bottom: 20px;
            letter-spacing: -0.5px;
        }

        .search-box {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 10px;
        }

        .search-box::placeholder {
            color: var(--text-secondary);
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .filter-btn {
            flex: 1;
            padding: 8px 16px;
            background-color: var(--bg-secondary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .filter-btn.active {
            background-color: var(--accent);
            color: white;
        }

        /* 2-Column Notes Layout */
        .notes-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            -webkit-overflow-scrolling: touch;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            grid-auto-rows: max-content;
            gap: 8px;
            align-content: start;
            max-height: 100%;
        }

        /* Swipe container for notes */
        .note-swipe-container {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            min-height: auto;
        }

        .note-swipe-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--danger);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 20px;
            color: white;
            font-size: 18px;
            z-index: 1;
            border-radius: 10px;
        }

        .note-item {
            background-color: var(--bg-secondary);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: transform 0.2s ease-out;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 110px;
            z-index: 2;
            touch-action: pan-y;
            width: 100%;
            transform: translateX(0);
            box-sizing: border-box;
        }

        .note-item.swiping {
            transition: none;
        }

        .note-item:active:not(.swiping) {
            transform: scale(0.98);
        }

        .note-item.pinned {
            background-color: var(--note-bg);
        }

        .note-item-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 4px;
        }

        .note-item-title {
            font-weight: 500;
            font-size: 15px;
            color: var(--text-primary);
            flex: 1;
            margin-right: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .note-item-icons {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .pin-icon {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .pin-icon.pinned {
            color: var(--warning);
        }

        .note-item-preview {
            color: var(--text-secondary);
            font-size: 13px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            line-height: 1.2;
            margin-bottom: 4px;
            -webkit-box-orient: vertical;
            margin-bottom: 6px;
            line-height: 1.3;
            flex-grow: 1;
        }

        .note-item-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: auto;
        }

        /* Save Status Indicator */
        .save-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }

        .save-status.show {
            opacity: 1;
            transform: translateY(0);
        }

        .save-status.saving {
            background-color: var(--warning);
            color: white;
        }

        .save-status.saved {
            background-color: #34c759;
            color: white;
        }

        .save-status.error {
            background-color: var(--danger);
            color: white;
        }

        /* Editor */
        .editor-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary);
            z-index: 20;
            display: none;
            flex-direction: column;
        }

        .editor-container.active {
            display: flex;
        }

        .editor-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--bg-primary);
        }

        .back-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--accent);
            padding: 8px;
            margin-right: 12px;
        }

        .editor-title {
            flex: 1;
            font-size: 20px;
            font-weight: 500;
            background: none;
            border: none;
            color: var(--text-primary);
            padding: 0;
            min-width: 0; /* Allow shrinking */
        }

        .editor-actions {
            display: flex;
            gap: 16px;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .action-btn {
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 8px;
            transition: all 0.2s;
        }

        .action-btn:active {
            transform: scale(0.9);
        }

        .action-btn.active {
            color: var(--warning);
        }

        .editor-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .editor-textarea {
            width: 100%;
            min-height: 100%;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 17px;
            line-height: 1.6;
            font-family: inherit;
            outline: none;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .editor-textarea:focus {
            outline: none;
        }

        /* Formatting styles for the contenteditable editor */
        .editor-textarea .bold {
            font-weight: bold;
        }

        .editor-textarea .italic {
            font-style: italic;
        }

        .editor-textarea .underline {
            text-decoration: underline;
        }

        .editor-textarea .bold-italic {
            font-weight: bold;
            font-style: italic;
        }

        .editor-textarea .italic-underline {
            font-style: italic;
            text-decoration: underline;
        }

        .editor-textarea .bold-underline {
            font-weight: bold;
            text-decoration: underline;
        }

        .editor-textarea .bold-italic-underline {
            font-weight: bold;
            font-style: italic;
            text-decoration: underline;
        }

        .editor-footer {
            padding: 12px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-secondary);
            background-color: var(--bg-primary);
        }

        /* Empty state */
        .empty-state {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: var(--text-secondary);
            padding: 40px;
            text-align: center;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 24px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 20px;
            margin-bottom: 8px;
            font-weight: 300;
        }

        .empty-state-subtext {
            font-size: 16px;
            color: var(--text-secondary);
        }

        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            background-color: var(--accent);
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 12px var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 100;
        }

        .fab:active {
            transform: scale(0.95);
        }

        .fab svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        .fab.hidden {
            display: none;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 5px 20px var(--shadow);
            max-width: 320px;
            width: 90%;
        }

        .modal-header {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 16px;
        }

        .modal-body {
            margin-bottom: 24px;
            color: var(--text-secondary);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .btn-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-danger {
            background-color: var(--danger);
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* AI Modal specific styles */
        .ai-input-group {
            margin-bottom: 15px;
        }
        
        .ai-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .ai-input {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .ai-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .ai-textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 14px;
            min-height: 80px;
            resize: vertical;
        }

        /* Hide scrollbar but keep functionality */
        .notes-list::-webkit-scrollbar,
        .editor-content::-webkit-scrollbar {
            display: none;
        }

        .notes-list,
        .editor-content {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Swipe hint text */
        .swipe-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
            pointer-events: none;
        }

        .swipe-hint.show {
            opacity: 1;
        }
    
.note-swipe-container { min-height: auto; }
.notes-list { overflow-y: auto; }

/* Force exactly two columns at all widths */
.notes-list { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }

@media (max-width: 600px) {
    .editor-header {
        padding: 16px 10px; /* Reduce padding on mobile */
    }
    
    .editor-actions {
        gap: 8px; /* Tighter gap on mobile */
    }
    
    .action-btn {
        padding: 8px 4px; /* Tighter buttons */
    }
}

</style>
</head>
<body>
    <!-- Save Status Indicator -->
    <div class="save-status" id="saveStatus"></div>

    <!-- Swipe Hint -->
    <div class="swipe-hint" id="swipeHint">Swipe left to delete</div>

    <div class="container">
        <!-- Notes List -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="app-title">Notes</div>
                <input type="text" class="search-box" placeholder="Search notes..." id="searchBox">
                <div class="filter-buttons">
                    <button class="filter-btn active" onclick="filterNotes('all')">All</button>
                    <button class="filter-btn" onclick="filterNotes('pinned')">Pinned</button>
                </div>
            </div>
            <div class="notes-list" id="notesList"></div>
        </div>

        <!-- Editor -->
        <div class="editor-container" id="editorContainer">
            <div class="editor-header">
                <button class="back-btn" onclick="closeEditor()">‚Äπ</button>
                <input type="text" class="editor-title" id="noteTitle" placeholder="Untitled Note">
                <div class="editor-actions">
                    <button class="action-btn" id="aiBtn" onclick="toggleAIModal()">‚ú®</button>
                    <button class="action-btn" id="pinBtn" onclick="togglePin()">üìå</button>
                </div>
            </div>
            
            <div class="editor-content">
                <div class="editor-textarea" id="noteContent" contenteditable="true" 
                     data-placeholder="Start typing... 

Formatting Shortcuts (Type and press Space/Enter):
*bold* ‚Üí bold
**italic** ‚Üí italic
***bold italic*** ‚Üí bold italic
_underlined_ ‚Üí underlined

> Type &gt; for quote
# Type # for H1
## Type ## for H2"></div>
            </div>
            
            <div class="editor-footer">
                <span id="lastSaved">Auto-saved</span>
                <span id="charCount">0 characters</span>
            </div>
        </div>
    </div>

    <!-- Floating Action Button -->
    <button class="fab" id="fab" onclick="createNewNote()">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
        </svg>
    </button>

    <!-- Delete Confirmation Modal -->
    <div class="modal" id="deleteModal">
        <div class="modal-content">
            <div class="modal-header">Delete Note</div>
            <div class="modal-body">
                Are you sure you want to delete this note? This action cannot be undone.
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-danger" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <!-- AI Modal -->
    <div class="modal" id="aiModal">
        <div class="modal-content">
            <div class="modal-header">AI Assist ‚ú®</div>
            <div class="modal-body">
                <div class="ai-input-group">
                    <label class="ai-label">Gemini API Key</label>
                    <input type="password" id="aiApiKey" class="ai-input" placeholder="Paste your API key here">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeAIModal()">Cancel</button>
                <button class="btn btn-secondary" style="background-color: var(--accent); color: white;" onclick="runAITask()" id="runAiBtn">Restructure</button>
            </div>
        </div>
    </div>

    <style>
        /* Placeholder styling for contenteditable */
        .editor-textarea:empty:before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            font-style: italic;
            white-space: pre-wrap;
        }
        
        .editor-textarea:focus:before {
            opacity: 0.7;
        }
        
        .editor-textarea:not(:empty):before {
            display: none;
        }
    </style>

    <script>
        // State Management
        let notes = [];
        let currentNote = null;
        let searchTerm = '';
        let filterType = 'all';
        let autoSaveTimer = null;
        let saveStatusTimer = null;
        let swipeNoteId = null;
        let isProcessingInput = false;

        // Improved swipe state management
        let touchStarted = false;
        let isSwipeActive = false;
        let startX = 0;
        let startY = 0;
        let currentX = 0;
        let currentY = 0;
        let swipeThreshold = 60;
        let maxSwipeDistance = 120;
        let minSwipeDistance = 15;
        let swipeDirectionLocked = false;

        // Formatting state
        let formatTimer = null;
        let lastProcessedContent = '';

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadNotes();
            renderNotesList();
            
            // Handle initial URL if there's a note hash
            if (window.location.hash && window.location.hash.startsWith('#note-')) {
                const noteId = window.location.hash.replace('#note-', '');
                const note = notes.find(n => n.id === noteId);
                if (note) {
                    currentNote = note;
                    openEditor();
                } else {
                    history.replaceState({ view: 'list' }, '', window.location.pathname);
                }
            } else {
                history.replaceState({ view: 'list' }, '', window.location.pathname);
            }
            
            // Event listeners
            document.getElementById('searchBox').addEventListener('input', handleSearch);
            document.getElementById('noteTitle').addEventListener('input', handleTitleChange);
            
            const noteContent = document.getElementById('noteContent');
            noteContent.addEventListener('input', handleContentChange);
            noteContent.addEventListener('keydown', handleKeyDown);
            noteContent.addEventListener('paste', handlePaste);
            
            // Create demo notes if none exist
            if (notes.length === 0) {
                createDemoNotes();
                showSwipeHint();
            }
        });

        function createDemoNotes() {
            const demoNotes = [
                {
                    id: generateId(),
                    title: 'Welcome to Notes!',
                    content: 'This is your new notes app with automatic formatting!\n\nTry typing:\n*bold text* and press space\n**italic text** and press space\n***bold italic*** and press space\n_underlined text_ and press space\n\nCombine them:\n_*bold underlined*_\n_**italic underlined**_\n_***bold italic underlined***_',
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    isPinned: false
                },
                {
                    id: generateId(),
                    title: 'Ideas',
                    content: 'Random thoughts and ideas:\n1. Learn a new language\n2. Start a garden\n3. Write a blog\n4. Travel to Japan',
                    createdAt: new Date(Date.now() - 3600000).toISOString(),
                    updatedAt: new Date(Date.now() - 3600000).toISOString(),
                    isPinned: true
                },
                {
                    id: generateId(),
                    title: 'Meeting Notes',
                    content: 'Project kickoff meeting\n‚Ä¢ Discussed timeline\n‚Ä¢ Assigned roles\n‚Ä¢ Set deadlines\n\nNext meeting: Friday',
                    createdAt: new Date(Date.now() - 39600000).toISOString(),
                    updatedAt: new Date(Date.now() - 39600000).toISOString(),
                    isPinned: false
                }
            ];
            
            notes = demoNotes;
            saveNotes();
        }

        function showSwipeHint() {
            const hint = document.getElementById('swipeHint');
            hint.classList.add('show');
            setTimeout(() => {
                hint.classList.remove('show');
            }, 3000);
        }

        // Note Management Functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function createNewNote() {
            const newNote = {
                id: generateId(),
                title: 'Untitled Note',
                content: '',
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                isPinned: false
            };
            
            notes.unshift(newNote);
            currentNote = newNote;
            saveNotes();
            renderNotesList();
            openEditor();
        }

        function selectNote(noteId) {
            currentNote = notes.find(note => note.id === noteId);
            if (!currentNote) return;
            openEditor();
        }

        function openEditor() {
            if (!currentNote) return;
            
            history.pushState({ view: 'editor', noteId: currentNote.id }, '', `#note-${currentNote.id}`);
            
            document.getElementById('sidebar').classList.add('hidden');
            document.getElementById('editorContainer').classList.add('active');
            document.getElementById('fab').classList.add('hidden');
            
            document.getElementById('noteTitle').value = currentNote.title;
            const noteContent = document.getElementById('noteContent');
            noteContent.innerHTML = '';
            
            // Simple formatting for initial load (visual only, actual content is HTML in our new model)
            // But wait, our 'currentNote.content' is now HTML from handleContentChange.
            // So we just dump it in.
            noteContent.innerHTML = currentNote.content;
            
            document.getElementById('pinBtn').classList.toggle('active', currentNote.isPinned);
            
            updateCharCount();
            updateLastSaved();
        }

        function closeEditor() {
            document.getElementById('sidebar').classList.remove('hidden');
            document.getElementById('editorContainer').classList.remove('active');
            document.getElementById('fab').classList.remove('hidden');
            renderNotesList();
            
            if (window.location.hash) {
                history.replaceState({ view: 'list' }, '', window.location.pathname);
            }
        }

        function handleTitleChange(e) {
            if (!currentNote) return;
            currentNote.title = e.target.value || 'Untitled Note';
            autoSave();
        }

        function handleContentChange(e) {
            if (!currentNote || isProcessingInput) return;
            
            // Update the note content with the HTML content to preserve formatting
            // We use innerHTML now because the formatting is DOM-based, not text-based
            currentNote.content = document.getElementById('noteContent').innerHTML;
            updateCharCount();
            autoSave();
        }

        async function handleKeyDown(e) {
            // Handle Space and Enter for Markdown Shortcuts
            if (e.key === ' ' || e.key === 'Enter') {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                const textNode = range.startContainer;
                
                // Only trigger if we are in a text node
                if (textNode.nodeType === Node.TEXT_NODE) {
                    const text = textNode.textContent;
                    const cursorOffset = range.startOffset;
                    const textBeforeCursor = text.slice(0, cursorOffset);
                    
                    // Patterns to check
                    // We check strict patterns that end right at the cursor
                    // The 'match' will capture the content inside the markers
                    
                    const patterns = [
                        { regex: /(\*\*\*)([^*]+)(\*\*\*)$/, tag: 'span', className: 'bold-italic' }, // ***bold italic***
                        { regex: /(\*\*)([^*]+)(\*\*)$/, tag: 'span', className: 'italic' },          // **italic**
                        { regex: /(\*)([^*]+)(\*)$/, tag: 'span', className: 'bold' },              // *bold*
                        { regex: /(_)([^_]+)(_)$/, tag: 'span', className: 'underline' },            // _underline_
                    ];

                    for (const pattern of patterns) {
                        const match = textBeforeCursor.match(pattern.regex);
                        if (match) {
                            // match[0] is the whole match (e.g. *bold*)
                            // match[1] is the start marker
                            // match[2] is the content
                            // match[3] is the end marker
                            
                            // Prevent the space/enter from inserting yet if we want to handle it manually,
                            // OR let it happen but after our modification.
                            // Actually, if we modify DOM, the event default might fail or be weird.
                            // Best to prevent default, process, then re-add the char if needed.
                            
                            // But wait, if we are in middle of text, replacing might be tricky.
                            // Let's assume end-of-editing context.
                            
                            const matchLength = match[0].length;
                            const matchStart = cursorOffset - matchLength;
                            
                            // Split the text node to isolate the part we want to replace
                            // 1. Split at match end (cursor)
                            const remainingText = textNode.splitText(cursorOffset);
                            // 2. Split at match start
                            const middleTextNode = textNode.splitText(matchStart);
                            // Now middleTextNode contains exactly "*bold*"
                            
                            // Create the formatted element
                            const span = document.createElement(pattern.tag);
                            if (pattern.className) span.className = pattern.className;
                            span.textContent = match[2]; // The inner content
                            
                            // Replace the plain text node with the span
                            middleTextNode.parentNode.replaceChild(span, middleTextNode);
                            
                            // Add a Zero Width Space or just a regular Space after to break out of the style?
                            // Browsers often merge typing into the previous span. 
                            // Adding a ZWSP (\u200B) helps break the context.
                            // If the user hit Space, we should add a real space.
                            
                            const suffix = document.createTextNode(e.key === 'Enter' ? '\n' : '\u00A0'); // nbsp for space to ensure visibility
                            
                            // If Enter, we might want default behavior, but we just modified DOM. 
                            // execCommand('insertLineBreak') is safer for Enter.
                            
                            // Let's simplify: insert a normal space text node after.
                            if (e.key === ' ') {
                                // Insert space after the span
                                const spaceNode = document.createTextNode('\u00A0');
                                span.parentNode.insertBefore(spaceNode, remainingText);
                                
                                // Move cursor to after the space
                                range.setStartAfter(spaceNode);
                                range.setEndAfter(spaceNode);
                                selection.removeAllRanges();
                                selection.addRange(range);
                                
                                e.preventDefault(); // We handled the space
                                handleContentChange(); // Trigger save
                                return; 
                            }
                            
                            // If Enter, we let the browser handle it? 
                            // Often safer to prevent default and insert break manually to ensure we are OUT of the span.
                            if (e.key === 'Enter') {
                                // For now, let's just create the styling and let default Enter happen?
                                // No, default enter might duplicate the span styling on the new line.
                                // It's better to break out.
                                
                                const br = document.createElement('div'); // Standard block for new line in some browsers, or br
                                // Actually, let's just insert a text node with space and let user continue?
                                // No, Enter means new line.
                                
                                // Let's just finish the formatting replacement.
                                // And let the event bubble? 
                                // if we split the node, the cursor is at the beginning of 'remainingText'.
                                // restoring cursor there.
                                range.setStart(remainingText, 0);
                                range.setEnd(remainingText, 0);
                                selection.removeAllRanges();
                                selection.addRange(range);
                                
                                // We rely on default behavior for Enter now, hopefully it works.
                                handleContentChange();
                                return;
                            }
                        }
                    }
                }
            }
        }

        // Removed legacy formatting functions:
        // scheduleFormatting, getPlainText, processFormatting, convertTextToFormattedHTML, restoreCursorPosition

        function autoSave() {
            clearTimeout(autoSaveTimer);
            showSaveStatus('saving');
            
            autoSaveTimer = setTimeout(() => {
                if (currentNote) {
                    currentNote.updatedAt = new Date().toISOString();
                    const saved = saveNotes();
                    if (saved) {
                        updateLastSaved();
                        showSaveStatus('saved');
                    } else {
                        showSaveStatus('error');
                    }
                }
            }, 800);
        }

        function togglePin() {
            if (!currentNote) return;
            currentNote.isPinned = !currentNote.isPinned;
            document.getElementById('pinBtn').classList.toggle('active', currentNote.isPinned);
            saveNotes();
            // Force re-render of the list to show/hide pin icon in sidebar
            renderNotesList();
        }

        function deleteNoteById(noteId) {
            swipeNoteId = noteId;
            document.getElementById('deleteModal').classList.add('show');
        }

        function confirmDelete() {
            if (!swipeNoteId) return;
            
            notes = notes.filter(note => note.id !== swipeNoteId);
            saveNotes();
            
            if (currentNote && currentNote.id === swipeNoteId) {
                currentNote = null;
                closeEditor();
                history.replaceState({ view: 'list' }, '', window.location.pathname);
            }
            
            const modal = document.getElementById('deleteModal');
            modal.classList.remove('show');
            swipeNoteId = null;
            
            renderNotesList();
        }

        // Swipe handling functions (unchanged)
        function handleTouchStart(e, noteId) {
            touchStarted = true;
            isSwipeActive = false;
            swipeDirectionLocked = false;
            
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
            currentX = startX;
            currentY = startY;
            
            swipeNoteId = noteId;
        }

        function handleTouchMove(e) {
            if (!touchStarted) return;
            
            const touch = e.touches[0];
            currentX = touch.clientX;
            currentY = touch.clientY;
            
            const deltaX = startX - currentX;
            const deltaY = Math.abs(currentY - startY);
            const absDeltaX = Math.abs(deltaX);
            
            if (!swipeDirectionLocked && (absDeltaX > minSwipeDistance || deltaY > minSwipeDistance)) {
                swipeDirectionLocked = true;
                
                if (absDeltaX > deltaY && deltaX > 0) {
                    isSwipeActive = true;
                    const noteContainer = document.querySelector(`[data-note-id="${swipeNoteId}"]`);
                    const noteItem = noteContainer ? noteContainer.querySelector('.note-item') : null;
                    if (noteItem) {
                        noteItem.classList.add('swiping');
                    }
                } else {
                    touchStarted = false;
                    swipeNoteId = null;
                    return;
                }
            }
            
            if (isSwipeActive) {
                e.preventDefault();
                
                if (deltaX > 0) {
                    const swipeDistance = Math.min(deltaX, maxSwipeDistance);
                    const noteContainer = document.querySelector(`[data-note-id="${swipeNoteId}"]`);
                    const noteItem = noteContainer ? noteContainer.querySelector('.note-item') : null;
                    
                    if (noteItem) {
                        noteItem.style.transform = `translateX(-${swipeDistance}px)`;
                        
                        if (deltaX > swipeThreshold * 0.7) {
                            noteItem.style.transition = 'none';
                        }
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (!touchStarted) return;
            
            const deltaX = startX - currentX;
            const noteContainer = document.querySelector(`[data-note-id="${swipeNoteId}"]`);
            const noteItem = noteContainer ? noteContainer.querySelector('.note-item') : null;
            
            if (isSwipeActive && noteItem) {
                noteItem.classList.remove('swiping');
                
                if (deltaX > swipeThreshold) {
                    noteItem.style.transition = 'transform 0.2s ease-out';
                    noteItem.style.transform = `translateX(-${maxSwipeDistance}px)`;
                    
                    setTimeout(() => {
                        deleteNoteById(swipeNoteId);
                    }, 100);
                } else {
                    noteItem.style.transition = 'transform 0.2s ease-out';
                    noteItem.style.transform = 'translateX(0px)';
                    
                    setTimeout(() => {
                        if (noteItem) {
                            noteItem.style.transition = '';
                        }
                    }, 250);
                }
            } else if (!isSwipeActive && swipeNoteId && deltaX <= minSwipeDistance) {
                selectNote(swipeNoteId);
            }
            
            touchStarted = false;
            isSwipeActive = false;
            swipeDirectionLocked = false;
            if (deltaX <= swipeThreshold) {
                swipeNoteId = null;
            }
        }

        function handleNoteClick(e, noteId) {
            if (isSwipeActive) {
                e.preventDefault();
                return;
            }
            selectNote(noteId);
        }

        // Search and Filter
        function handleSearch(e) {
            searchTerm = e.target.value.toLowerCase();
            renderNotesList();
        }

        function filterNotes(type) {
            filterType = type;
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            renderNotesList();
        }

        // UI Functions
        function renderNotesList() {
            const notesList = document.getElementById('notesList');
            let filteredNotes = notes;
            
            if (filterType === 'pinned') {
                filteredNotes = filteredNotes.filter(note => note.isPinned);
            }
            
            if (searchTerm) {
                filteredNotes = filteredNotes.filter(note => 
                    note.title.toLowerCase().includes(searchTerm) ||
                    note.content.toLowerCase().includes(searchTerm)
                );
            }
            
            filteredNotes.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                return new Date(b.updatedAt) - new Date(a.updatedAt);
            });
            
            notesList.innerHTML = '';
            
            if (filteredNotes.length === 0) {
                notesList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <div class="empty-state-text">No notes found</div>
                        <div class="empty-state-subtext">Tap the + button to create your first note</div>
                    </div>
                `;
                return;
            }
            
            filteredNotes.forEach(note => {
                const noteContainer = document.createElement('div');
                noteContainer.className = 'note-swipe-container';
                noteContainer.dataset.noteId = note.id;
                
                const preview = note.content.replace(/[*_]/g, '').substring(0, 100);
                
                noteContainer.innerHTML = `
                    <div class="note-swipe-background">
                        üóëÔ∏è
                    </div>
                    <div class="note-item ${note.isPinned ? 'pinned' : ''}">
                        <div class="note-item-header">
                            <div class="note-item-title">${note.title}</div>
                            <div class="note-item-icons">
                                ${note.isPinned ? '<span class="pin-icon pinned">üìå</span>' : ''}
                            </div>
                        </div>
                        <div class="note-item-preview">${preview}${note.content.length > 100 ? '...' : ''}</div>
                        <div class="note-item-meta">${formatDate(note.updatedAt)}</div>
                    </div>
                `;
                
                noteContainer.addEventListener('touchstart', (e) => handleTouchStart(e, note.id), { passive: false });
                noteContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                noteContainer.addEventListener('touchend', handleTouchEnd, { passive: false });
                noteContainer.addEventListener('click', (e) => handleNoteClick(e, note.id));
                
                notesList.appendChild(noteContainer);
            });
        }

        function showSaveStatus(status, customMessage = '') {
            const saveStatus = document.getElementById('saveStatus');
            const statusText = {
                'saving': 'Saving...',
                'saved': 'Saved!',
                'error': 'Save failed'
            };
            
            saveStatus.textContent = status === 'custom' ? customMessage : statusText[status];
            saveStatus.className = `save-status show ${status === 'custom' ? 'saving' : status}`;
            
            clearTimeout(saveStatusTimer);
            if (status !== 'saving' && status !== 'custom') {
                saveStatusTimer = setTimeout(() => {
                    saveStatus.classList.remove('show');
                }, 2000);
            }
        }

        function updateCharCount() {
            const content = document.getElementById('noteContent').innerText || '';
            document.getElementById('charCount').textContent = `${content.length} characters`;
        }

        function updateLastSaved() {
            document.getElementById('lastSaved').textContent = 'Auto-saved';
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
            if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
            if (diff < 604800000) return `${Math.floor(diff / 86400000)}d ago`;
            
            return date.toLocaleDateString();
        }

        // Storage Functions
        function saveNotes() {
            try {
                localStorage.setItem('notes', JSON.stringify(notes));
                return true;
            } catch (e) {
                console.error('Failed to save notes:', e);
                return false;
            }
        }

        function loadNotes() {
            try {
                const savedNotes = localStorage.getItem('notes');
                if (savedNotes) {
                    notes = JSON.parse(savedNotes);
                }
            } catch (e) {
                console.error('Failed to load notes:', e);
                notes = [];
            }
        }

        function closeModal() {
            const modal = document.getElementById('deleteModal');
            modal.classList.remove('show');
            
            if (swipeNoteId) {
                const noteContainer = document.querySelector(`[data-note-id="${swipeNoteId}"]`);
                
                if (noteContainer) {
                    const noteItem = noteContainer.querySelector('.note-item');
                    
                    if (noteItem) {
                        noteItem.style.transition = 'transform 0.3s ease-out';
                        noteItem.style.transform = 'translateX(0px)';
                        
                        setTimeout(() => {
                            if (noteItem) {
                                noteItem.style.transition = '';
                            }
                        }, 350);
                    }
                }
            }
            
            swipeNoteId = null;
        }

        // AI Functions
        function toggleAIModal() {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                // Auto-run if key exists
                runAITask(savedKey);
            } else {
                // Show modal if no key
                const modal = document.getElementById('aiModal');
                modal.classList.add('show');
                const savedKeyInput = localStorage.getItem('gemini_api_key');
                if (savedKeyInput) document.getElementById('aiApiKey').value = savedKeyInput;
            }
        }

        function closeAIModal() {
            document.getElementById('aiModal').classList.remove('show');
        }

        async function runAITask(savedKey = null) {
            if (!currentNote) return;
            
            let apiKey = savedKey;
            
            // If no saved key passed, get from input
            if (!apiKey) {
                apiKey = document.getElementById('aiApiKey').value.trim();
                
                if (!apiKey) {
                    alert('Please enter a valid Gemini API Key');
                    return;
                }
                
                // Save settings
                localStorage.setItem('gemini_api_key', apiKey);
            }
            
            // UI Feedback
            const btn = document.getElementById('runAiBtn');
            const originalText = btn.textContent;
            
            if (!savedKey) {
                // Modal is open
                btn.textContent = 'Processing...';
                btn.disabled = true;
            } else {
                // Background process
                showSaveStatus('custom', '‚ú® AI Processing...');
            }

            // Hardcoded Strict Prompt
            const systemPrompt = "Restructure the following text to improve grammar, typos, and clarity. Return ONLY the restructured text. Do NOT provide options. Do NOT include any preamble, introductory text, or markdown code blocks (like ```markdown). Just the text.";
            
            try {
                const noteContent = currentNote.content; 
                
                // Construct the payload
                const payload = {
                    contents: [{
                        parts: [{
                            text: `${systemPrompt}\n\n${noteContent}`
                        }]
                    }]
                };
                
                // Using gemini-flash-latest as it is free and stable
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API Error');
                }
                
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    const newContent = data.candidates[0].content.parts[0].text;
                    
                    // Simple logic: maintain line breaks but strip markdown if necessary, 
                    // or let our new editor handle it? 
                    // The AI returns Markdown usually.
                    // We need to convert it to HTML for our editor.
                    
                    // Since we removed 'convertTextToFormattedHTML', we need a simple converter for initial load.
                    // Or we just set innerText and let user format it?
                    // Better: User `marked` library or simple replacement.
                    // Since we are "Trigger based", we don't auto format bulk text.
                    // So we just dump plain text?
                    // User might want to see the bold text immediately.
                    
                    // For now, let's just use a very simple formatter for the AI output
                    // to basic HTML so it looks nice.
                    
                    let htmlContent = newContent
                        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
                        .replace(/\*\*(.*?)\*\*/g, '<span class="bold">$1</span>')
                        .replace(/\*(.*?)\*/g, '<span class="italic">$1</span>') // single * is italic usually in MD
                        .replace(/\n/g, '<br>');

                    currentNote.content = htmlContent;
                    document.getElementById('noteContent').innerHTML = htmlContent;
                    
                    // Save and re-format
                    handleContentChange();
                    closeAIModal();
                    
                    showSaveStatus('saved');
                } else {
                    throw new Error('Invalid response structure');
                }
                
            } catch (e) {
                console.error('AI Error:', e);
                alert('AI Processing Failed: ' + e.message);
                showSaveStatus('error');
            } finally {
                if (!savedKey) {
                    btn.textContent = originalText;
                    btn.disabled = false;
                } else {
                     // Hide status if success (saved will show) or error
                     // But if error, alert showed. 
                     // If success, 'saved' call in block handles it.
                }
            }
        }

        // Event listeners
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                if (event.target.id === 'deleteModal') closeModal();
                if (event.target.id === 'aiModal') closeAIModal();
            }
        }

        window.addEventListener('popstate', function(e) {
            const editorActive = document.getElementById('editorContainer').classList.contains('active');
            
            if (editorActive) {
                closeEditor();
            } else if (e.state && e.state.view === 'editor' && e.state.noteId) {
                const note = notes.find(n => n.id === e.state.noteId);
                if (note) {
                    currentNote = note;
                    document.getElementById('sidebar').classList.add('hidden');
                    document.getElementById('editorContainer').classList.add('active');
                    document.getElementById('fab').classList.add('hidden');
                    
                    document.getElementById('noteTitle').value = currentNote.title;
                    const noteContent = document.getElementById('noteContent');
                    
                    // Direct HTML injection
                    noteContent.innerHTML = currentNote.content;
                    
                    document.getElementById('pinBtn').classList.toggle('active', currentNote.isPinned);
                    
                    updateCharCount();
                    updateLastSaved();
                }
            }
        });

        window.addEventListener('beforeunload', function() {
            if (currentNote) {
                currentNote.updatedAt = new Date().toISOString();
                saveNotes();
            }
        });
    </script>
</body>
</html>
